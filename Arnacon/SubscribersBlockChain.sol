// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract Subscribers is ERC721URIStorage {

    constructor() ERC721("SubscribersNetwork", "SNT") {}

    uint private counter = 1;
    event LogMessage(string message);

    address[] private addressList;
    string public currentUUID;
    mapping (address => uint256[]) public addressToTokenId;
    mapping(address => string) public addressToUUID;
    mapping(string => trioMapping) public uuidToTrio;

    function Subscribe(address _ownerAddress, string memory _userCID) public {

       require(validateAddress(_ownerAddress),"Wallet address isn't valid");
       emit LogMessage("good");
       createCollectible(_ownerAddress, _userCID);
    }

    // this creates a new NFT that the owner of that NFT is the owner address( wallet ) and the ID is a UUID generated by me
    // and the URI of that token ---> means what the token saves is - string for how to call the owner -- ##ex : jo1.phone
    function createCollectible(address _ownerAddress, string memory cid) private returns (uint256) {
        
        uint256 newItemId = counter;

        _safeMint(_ownerAddress, newItemId); // connection between the owner address - the one who registered to the network

        string memory uuid = generateUUID(); // generate the uuid

        addressToUUID[_ownerAddress] = uuid;
        createCustomData(uuid, cid, "a", "b");
        _setTokenURI(newItemId, uuid); // the connection between the CIDPK and the ID
        currentUUID = uuid;
        if(checkIfOwnerAlreadyExist(_ownerAddress)){
            addressToTokenId[_ownerAddress].push(newItemId);
        }
        else {
            addressList.push(_ownerAddress);
            uint[] memory newOwnerForIds = new uint256[](1);
            newOwnerForIds[0] = newItemId;
            addressToTokenId[_ownerAddress] = newOwnerForIds;
        }

        counter += 1;

        return newItemId;
    }

    struct trioMapping {
        string CIDPK;
        string credentialsCID;
        string nameInTheServer;
    }


    function getCIDPK(string memory uuidOfUser) public view returns(string memory){
        return uuidToTrio[uuidOfUser].CIDPK;
    }
    
    // Future upgrade for more then one account
    function getItemIds(address _address) public view returns (uint[] memory) {
        return addressToTokenId[_address];
    }

    // Gets the UUID correspondeds to the address ( for V1 only 1 Address ( owner's public ) is associated with 1 UUID ) 
    function getUUIDFromAddress(address _address) public view returns(string memory){
        return addressToUUID[_address];
    }

    function checkIfOwnerAlreadyExist(address _ownerAddress) private view returns(bool){
        return (addressToTokenId[_ownerAddress]).length != 0;
    }

    // Tranasaction number 2 for the client ( user )
    function updateMappingOfCredentialsAndGiven(string memory key, string memory _CIDOfCredentials, string memory _nameFromProvider) public {
        uuidToTrio[key].credentialsCID = _CIDOfCredentials;
        uuidToTrio[key].nameInTheServer = _nameFromProvider;
    }

    // Function to create a new instance of that trio map.
    function createCustomData(string memory key, string memory _currentCID, string memory _myCredentialsFromProvider, string memory _myName) private {
        uuidToTrio[key] = trioMapping(_currentCID, _myCredentialsFromProvider, _myName);
    }

    function validateAddress(address _addressToValidate) private pure returns (bool){ // Ethereum account or contract on the Ethereum network. It only ensures that the address is in the expected format
        return _addressToValidate != address(0);
    }
    
    function generateUUID() private view returns (string memory) {
        bytes32 hash = keccak256(abi.encodePacked(block.timestamp, msg.sender));
        return toHexString(hash);
    }

    function toHexString(bytes32 value) private pure returns (string memory) {
        bytes memory buffer = new bytes(64);
        for (uint256 i = 0; i < 32; i++) {
            buffer[i * 2] = bytes1(hexDigit(uint8(value[i]) >> 4));
            buffer[i * 2 + 1] = bytes1(hexDigit(uint8(value[i]) & 0x0f));
        }
        return string(buffer);
    }

    function hexDigit(uint8 value) private pure returns (bytes1) {
        if (value < 10) {
            return bytes1(uint8(bytes1("0")) + value);
        } else {
            return bytes1(uint8(bytes1("a")) + value - 10);
        }
    }
}